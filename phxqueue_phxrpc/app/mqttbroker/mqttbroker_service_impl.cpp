/* mqttbroker_service_impl.cpp

 Generated by phxrpc_pb2service from mqttbroker.proto

*/

#include "mqttbroker_service_impl.h"

#include "phxrpc/file.h"

#include "phxqueue/lock.h"

#include "phxqueue_phxrpc/app/lock/lock_client.h"
#include "phxqueue_phxrpc/comm.h"
#include "phxqueue_phxrpc/plugin.h"
#include "phxqueue_phxrpc/producer.h"

#include "event_loop_server.h"
#include "mqtt/mqtt_msg.h"
#include "mqtt/mqtt_packet_id.h"
#include "mqtt/mqtt_session.h"
#include "mqttbroker_server_config.h"


using namespace std;


constexpr char *KEY_BROKER_CLIENT2SESSION_PREFIX{"__broker__:client2session:"};
constexpr char *KEY_BROKER_TOPIC2CLIENT_PREFIX{"__broker__:topic2client:"};
constexpr char *KEY_BROKER_TOPIC2LOCK{"__broker__:topic2lock:"};


MqttBrokerServiceImpl::MqttBrokerServiceImpl(ServiceArgs_t &app_args,
        phxrpc::UThreadEpollScheduler *const worker_uthread_scheduler,
        const uint64_t session_id)
        : args_(app_args),
          worker_uthread_scheduler_(worker_uthread_scheduler),
          session_id_(session_id) {
}

MqttBrokerServiceImpl::~MqttBrokerServiceImpl() {
}

int MqttBrokerServiceImpl::PHXEcho(const google::protobuf::StringValue &req,
                                   google::protobuf::StringValue *resp) {
    resp->set_value(req.value());

    return 0;
}

int MqttBrokerServiceImpl::PhxHttpPublish(const phxqueue_phxrpc::mqttbroker::HttpPublishPb &req,
                                          phxqueue_phxrpc::mqttbroker::HttpPubackPb *resp) {
    // 1. check local session
    const auto sub_mqtt_session(args_.mqtt_session_mgr->GetByClientId(req.sub_client_id()));
    if (!sub_mqtt_session) {
        QLErr("GetByClientId err sub_client_id \"%s\"", req.sub_client_id().c_str());

        return -1;
    }

    // 2. publish to event_loop_server
    phxqueue_phxrpc::mqttbroker::MqttPublishPb mqtt_publish_pb;
    mqtt_publish_pb.CopyFrom(req.mqtt_publish());
    // mqtt-3.3.1-3: reset dup
    mqtt_publish_pb.set_dup(false);

    if (1 == mqtt_publish_pb.qos()) {
        uint16_t sub_packet_id{0};
        if (!args_.mqtt_packet_id_mgr->AllocPacketId(req.pub_client_id(),
                req.mqtt_publish().packet_identifier(), req.sub_client_id(), sub_packet_id)) {
            QLErr("sub_session_id %" PRIx64 " AllocPacketId err sub_client_id \"%s\"",
                  sub_mqtt_session->session_id, req.sub_client_id().c_str());

            return -1;
        }
        mqtt_publish_pb.set_packet_identifier(sub_packet_id);

        // ack_key = sub_client_id + sub_packet_id
        const string ack_key(req.sub_client_id() + ':' + to_string(sub_packet_id));
        void *data{nullptr};
        auto *mqtt_publish(new phxqueue_phxrpc::mqttbroker::MqttPublish);
        mqtt_publish->FromPb(mqtt_publish_pb);
        args_.server_mgr->SendAndWaitAck(sub_mqtt_session->session_id, mqtt_publish,
                                         worker_uthread_scheduler_, ack_key, data);

        phxqueue_phxrpc::mqttbroker::MqttPuback *puback{
                (phxqueue_phxrpc::mqttbroker::MqttPuback *)data};
        if (!puback) {
            QLErr("sub_session_id %" PRIx64 " server_mgr.SendAndWaitAck nullptr "
                  "qos %u ack_key \"%s\"", sub_mqtt_session->session_id,
                  req.mqtt_publish().qos(), ack_key.c_str());

            return -1;
        }

        QLInfo("sub_session_id %" PRIx64 " server_mgr.SendAndWaitAck ack_key \"%s\" qos %u",
               sub_mqtt_session->session_id, ack_key.c_str(), req.mqtt_publish().qos());

        int ret{puback->ToPb(resp->mutable_mqtt_puback())};

        delete puback;

        args_.mqtt_packet_id_mgr->ReleasePacketId(req.pub_client_id(),
                req.mqtt_publish().packet_identifier(), req.sub_client_id());

        if (0 != ret) {
            QLErr("ToPb err %d", ret);

            return ret;
        }
    } else {
        auto *mqtt_publish(new phxqueue_phxrpc::mqttbroker::MqttPublish);
        mqtt_publish->FromPb(mqtt_publish_pb);
        args_.server_mgr->Send(sub_mqtt_session->session_id, mqtt_publish);
        QLInfo("sub_session_id %" PRIx64 " server_mgr.Send sub_client_id \"%s\" qos %u",
               sub_mqtt_session->session_id, req.sub_client_id().c_str(),
               req.mqtt_publish().qos());
    }

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttConnect(const phxqueue_phxrpc::mqttbroker::MqttConnectPb &req,
                                          phxqueue_phxrpc::mqttbroker::MqttConnackPb *resp) {
    // 1. init local session
    const auto old_mqtt_session(args_.mqtt_session_mgr->GetByClientId(
            req.client_identifier()));
    if (old_mqtt_session) {
        if (old_mqtt_session->session_id == session_id_) {
            // mqtt-3.1.0-2: disconnect current connection

            args_.mqtt_session_mgr->DestroyBySessionId(session_id_);
            args_.server_mgr->DestroySession(session_id_);

            QLErr("%s err session_id %" PRIx64 " client_id \"%s\"", __func__,
                  session_id_, req.client_identifier().c_str());

            return -1;
        } else {
            // mqtt-3.1.4-2: disconnect other connection with same client_id
            args_.mqtt_session_mgr->DestroyBySessionId(old_mqtt_session->session_id);
            args_.server_mgr->DestroySession(old_mqtt_session->session_id);

            QLInfo("%s disconnect session_id old %" PRIx64 " new %" PRIx64
                   " client_id \"%s\"", __func__, old_mqtt_session->session_id,
                   session_id_, req.client_identifier().c_str());
        }
    }

    // mqtt connect: set client_id and init
    const auto mqtt_session(args_.mqtt_session_mgr->Create(
            req.client_identifier(), session_id_));
    mqtt_session->keep_alive = req.keep_alive();
    mqtt_session->Heartbeat();

    // 2. init remote session
    phxqueue_phxrpc::mqttbroker::SessionPb session_pb;
    // TODO:
    //session_pb.set_session_ip();
    session_pb.set_session_id(session_id_);

    const auto &session_attribute(session_pb.mutable_session_attribute());
    session_attribute->set_clean_session(req.clean_session());
    session_attribute->set_user_name(req.user_name());
    session_attribute->set_password(req.password());
    session_attribute->set_will_flag(req.will_flag());
    session_attribute->set_will_qos(req.will_qos());
    session_attribute->set_will_retain(req.will_retain());
    session_attribute->set_will_topic(req.will_topic());
    session_attribute->set_will_message(req.will_message());

    // 3. set remote session
    phxqueue::comm::RetCode ret{SetSessionByClientIdRemote(req.client_identifier(), -1, session_pb)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        // destroy local session
        args_.mqtt_session_mgr->DestroyBySessionId(session_id_);
        args_.server_mgr->DestroySession(session_id_);

        QLErr("session_id %" PRIx64 " client_id \"%s\" SetSessionByClientIdRemote err %d",
              session_id_, req.client_identifier().c_str(),
              phxqueue::comm::as_integer(ret));

        return phxqueue::comm::as_integer(ret);
    }

    // 3. response
    resp->set_session_present(!req.clean_session());
    resp->set_connect_return_code(0u);

    QLInfo("session_id %" PRIx64 " client_id \"%s\" keep_alive %u expire_time_ms %llu now %llu",
           session_id_, req.client_identifier().c_str(),
           mqtt_session->keep_alive, mqtt_session->expire_time_ms(),
           phxrpc::Timer::GetSteadyClockMS());

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttPublish(const phxqueue_phxrpc::mqttbroker::MqttPublishPb &req,
                                          google::protobuf::Empty *resp) {
    // 1. check local session
    MqttSession *mqtt_session{nullptr};
    phxqueue::comm::RetCode ret{CheckSession(mqtt_session)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("session_id %" PRIx64 " CheckSession err %d qos %u packet_id %d",
              session_id_, phxqueue::comm::as_integer(ret), req.qos(), req.packet_identifier());

        return phxqueue::comm::as_integer(ret);
    }

    // 2. get remote session
    //uint64_t version{0uLL};
    //phxqueue_phxrpc::mqttbroker::SessionPb session_pb;
    //ret = GetSessionByClientIdRemote(mqtt_session->client_id, version, session_pb);
    //if (phxqueue::comm::RetCode::RET_OK != ret) {
    //    FinishSession();
    //    QLErr("session_id %" PRIx64 " GetSessionByClientIdRemote err %d qos %u packet_id %d",
    //          data_flow_args_->session_id, phxqueue::comm::as_integer(ret),
    //          req.qos(), req.packet_identifier());

    //    return phxqueue::comm::as_integer(ret);
    //}

    // 2. enqueue
    phxqueue_phxrpc::mqttbroker::HttpPublishPb http_publish_pb;
    http_publish_pb.set_pub_client_id(mqtt_session->client_id);
    http_publish_pb.mutable_mqtt_publish()->CopyFrom(req);
    ret = EnqueueMessage(http_publish_pb);
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        FinishSession();
        QLErr("session_id %" PRIx64 " GetSessionByClientIdRemote err %d qos %u packet_id %d",
              session_id_, phxqueue::comm::as_integer(ret),
              req.qos(), req.packet_identifier());

        return phxqueue::comm::as_integer(ret);
    }

    // 3. ack
    if (1 == req.qos()) {
        phxqueue_phxrpc::mqttbroker::MqttPubackPb puback_pb;
        puback_pb.set_packet_identifier(req.packet_identifier());
        auto *puback(new phxqueue_phxrpc::mqttbroker::MqttPuback);
        puback->FromPb(puback_pb);
        args_.server_mgr->Send(session_id_, (phxrpc::BaseResponse *)puback);
    }

    // TODO: remove
    if (isprint(req.data().at(req.data().size() - 1)) && isprint(req.data().at(0))) {
        QLInfo("session_id %" PRIx64 " client_id \"%s\" qos %u packet_id %d topic \"%s\" data \"%s\"",
               session_id_, mqtt_session->client_id.c_str(), req.qos(),
               req.packet_identifier(), req.topic_name().c_str(), req.data().c_str());
    } else {
        QLInfo("session_id %" PRIx64 " client_id \"%s\" qos %u packet_id %d topic \"%s\" data.size %zu",
               session_id_, mqtt_session->client_id.c_str(), req.qos(),
               req.packet_identifier(), req.topic_name().c_str(), req.data().size());
    }

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttPuback(const phxqueue_phxrpc::mqttbroker::MqttPubackPb &req,
                                         google::protobuf::Empty *resp) {
    // 1. check local session
    MqttSession *mqtt_session{nullptr};
    phxqueue::comm::RetCode ret{CheckSession(mqtt_session)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("session_id %" PRIx64 " CheckSession err %d packet_id %d",
              session_id_, phxqueue::comm::as_integer(ret),
              req.packet_identifier());

        return phxqueue::comm::as_integer(ret);
    }

    // 2. puback to hsha_server
    auto *puback(new phxqueue_phxrpc::mqttbroker::MqttPuback);
    int ret2{puback->FromPb(req)};
    if (0 != ret2) {
        delete puback;
        QLErr("session_id %" PRIx64 " FromPb err %d packet_id %d",
              session_id_, ret2, req.packet_identifier());

        return ret2;
    }

    // ack_key = sub_client_id + sub_packet_id
    const string ack_key(mqtt_session->client_id + ':' + to_string(req.packet_identifier()));
    // forward puback and do not delete here
    ret2 = args_.server_mgr->Ack(ack_key, (void *)puback);
    if (0 != ret2) {
        QLErr("session_id %" PRIx64 " server_mgr.Ack err %d ack_key \"%s\"",
              session_id_, ret2, ack_key.c_str());

        return ret2;
    }

    QLInfo("session_id %" PRIx64 " packet_id %d",
           session_id_, req.packet_identifier());

    return ret2;
}

int MqttBrokerServiceImpl::PhxMqttPubrec(const phxqueue_phxrpc::mqttbroker::MqttPubrecPb &req,
                                         google::protobuf::Empty *resp) {
    return -1;
}

int MqttBrokerServiceImpl::PhxMqttPubrel(const phxqueue_phxrpc::mqttbroker::MqttPubrelPb &req,
                                         google::protobuf::Empty *resp) {
    return -1;
}

int MqttBrokerServiceImpl::PhxMqttPubcomp(const phxqueue_phxrpc::mqttbroker::MqttPubcompPb &req,
                                          google::protobuf::Empty *resp) {
    return -1;
}

int MqttBrokerServiceImpl::PhxMqttSubscribe(const phxqueue_phxrpc::mqttbroker::MqttSubscribePb &req,
                                            phxqueue_phxrpc::mqttbroker::MqttSubackPb *resp) {
    // 1. check local session
    MqttSession *mqtt_session{nullptr};
    phxqueue::comm::RetCode ret{CheckSession(mqtt_session)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("session_id %" PRIx64 " CheckSession err %d",
              session_id_, phxqueue::comm::as_integer(ret));

        return phxqueue::comm::as_integer(ret);
    }

    // 2. get retmote session
    uint64_t version{0uLL};
    phxqueue_phxrpc::mqttbroker::SessionPb session_pb;
    ret = GetSessionByClientIdRemote(mqtt_session->client_id, version, session_pb);
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        FinishSession();
        QLErr("session_id %" PRIx64 " GetSessionByClientIdRemote err %d packet_id %d",
              session_id_, phxqueue::comm::as_integer(ret),
              req.packet_identifier());

        return phxqueue::comm::as_integer(ret);
    }

    // 3. set topic_name -> client_id to lock
    vector<uint8_t> return_codes;
    return_codes.resize(req.topic_filters().size());
    for (int i{0}; req.topic_filters().size() > i; ++i) {

        // 3.1. get topic_name -> session_ids from lock
        uint64_t version{0uLL};
        string topic_pb_string;
        phxqueue::comm::RetCode ret{GetStringRemote(string(KEY_BROKER_TOPIC2CLIENT_PREFIX),
                req.topic_filters(i), version, topic_pb_string)};
        phxqueue_phxrpc::mqttbroker::TopicPb topic_pb;
        if (phxqueue::comm::RetCode::RET_ERR_KEY_NOT_EXIST != ret) {
            if (phxqueue::comm::RetCode::RET_OK != ret) {
                FinishSession();
                QLErr("session_id %" PRIx64 " GetStringRemote err %d packet_id %d topic \"%s\"",
                      session_id_, phxqueue::comm::as_integer(ret),
                      req.packet_identifier(), req.topic_filters(i).c_str());

                return_codes.at(i) = 0x80;

                continue;
            }

            // 3.2. modify topic
            if (!topic_pb.ParseFromString(topic_pb_string)) {
                FinishSession();
                QLErr("session_id %" PRIx64 " ParseFromString err packet_id %d",
                      session_id_, req.packet_identifier());

                return_codes.at(i) = 0x80;

                continue;
            }
        }

        const auto &subscribe_pb(topic_pb.add_subscribes());
        subscribe_pb->set_client_identifier(mqtt_session->client_id);
        if (req.qoss().size() > i) {
            if (1 >= req.qoss(i)) {
                subscribe_pb->set_qos(req.qoss(i));
                return_codes.at(i) = req.qoss(i);
            } else {
                subscribe_pb->set_qos(1);
                return_codes.at(i) = 0x01;
            }
        } else {
            subscribe_pb->set_qos(0);
            return_codes.at(i) = 0x00;
        }

        topic_pb_string.clear();
        if (!topic_pb.SerializeToString(&topic_pb_string)) {
            FinishSession();
            QLErr("session_id %" PRIx64 " SerializeToString err packet_id %d",
                  session_id_, req.packet_identifier());

            return_codes.at(i) = 0x80;

            continue;
        }

        // 3.3. set topic_name -> session_ids to lock
        ret = SetStringRemote(string(KEY_BROKER_TOPIC2CLIENT_PREFIX),
                              req.topic_filters(i), version, move(topic_pb_string));
        if (phxqueue::comm::RetCode::RET_OK != ret) {
            FinishSession();
            QLErr("session_id %" PRIx64 " SetStringRemote err %d packet_id %d topic \"%s\"",
                  session_id_, phxqueue::comm::as_integer(ret), req.packet_identifier(),
                  req.topic_filters(i).c_str());

            return_codes.at(i) = 0x80;

            continue;
        }

    }  // foreach req.topic_filters()

    // 4. response
    resp->set_packet_identifier(req.packet_identifier());
    resp->clear_return_codes();
    for (int i{0}; req.topic_filters().size() > i; ++i) {
        resp->add_return_codes(return_codes.at(i));
        QLVerb("topic \"%s\" return_code %x", req.topic_filters(i).c_str(), return_codes.at(i));
    }

    QLInfo("session_id %" PRIx64 " packet_id %d",
           session_id_, req.packet_identifier());

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttUnsubscribe(const phxqueue_phxrpc::mqttbroker::MqttUnsubscribePb &req,
                                              phxqueue_phxrpc::mqttbroker::MqttUnsubackPb *resp) {
    // 1. check local session
    MqttSession *mqtt_session{nullptr};
    phxqueue::comm::RetCode ret{CheckSession(mqtt_session)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("session_id %" PRIx64 " CheckSession err %d",
              session_id_, phxqueue::comm::as_integer(ret));

        return phxqueue::comm::as_integer(ret);
    }

    // 2. get remote session
    uint64_t version{0uLL};
    phxqueue_phxrpc::mqttbroker::SessionPb session_pb;
    ret = GetSessionByClientIdRemote(mqtt_session->client_id, version, session_pb);
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        FinishSession();
        QLErr("session_id %" PRIx64 " GetSessionByClientIdRemote err %d packet_id %d",
              session_id_, phxqueue::comm::as_integer(ret),
              req.packet_identifier());

        return phxqueue::comm::as_integer(ret);
    }

    // 3. remove topic_name -> client_id from lock
    for (int i{0}; req.topic_filters().size() > i; ++i) {

        // 3.1. get topic_name -> session_ids from lock
        uint64_t version{0uLL};
        string topic_pb_string;
        phxqueue::comm::RetCode ret{GetStringRemote(string(KEY_BROKER_TOPIC2CLIENT_PREFIX),
                req.topic_filters(i), version, topic_pb_string)};
        phxqueue_phxrpc::mqttbroker::TopicPb topic_pb_new;
        if (phxqueue::comm::RetCode::RET_ERR_KEY_NOT_EXIST != ret) {
            if (phxqueue::comm::RetCode::RET_OK != ret) {
                FinishSession();
                QLErr("session_id %" PRIx64 " GetStringRemote err %d packet_id %d topic \"%s\"",
                      session_id_, phxqueue::comm::as_integer(ret),
                      req.packet_identifier(), req.topic_filters(i).c_str());

                return phxqueue::comm::as_integer(ret);
            }

            // 3.2. modify topic
            phxqueue_phxrpc::mqttbroker::TopicPb topic_pb_old;
            if (!topic_pb_old.ParseFromString(topic_pb_string)) {
                FinishSession();
                QLErr("session_id %" PRIx64 " ParseFromString err packet_id %d topic \"%s\"",
                      session_id_, req.packet_identifier(), req.topic_filters(i).c_str());

                return -1;
            }

            for_each (topic_pb_old.subscribes().cbegin(), topic_pb_old.subscribes().cend(),
                    [&](const phxqueue_phxrpc::mqttbroker::SubscribePb &subscribe_pb) {
                        if (subscribe_pb.client_identifier() != mqtt_session->client_id) {
                            const auto &new_subscribe(topic_pb_new.add_subscribes());
                            new_subscribe->CopyFrom(subscribe_pb);
                        }
                    });
        }

        topic_pb_string.clear();
        if (!topic_pb_new.SerializeToString(&topic_pb_string)) {
            FinishSession();
            QLErr("session_id %" PRIx64 " SerializeToString err packet_id %d topic \"%s\"",
                  session_id_, req.packet_identifier(), req.topic_filters(i).c_str());

            return -1;
        }

        // 3.3. set topic_name -> session_ids to lock
        ret = SetStringRemote(string(KEY_BROKER_TOPIC2CLIENT_PREFIX),
                              req.topic_filters(i), version, move(topic_pb_string));
        if (phxqueue::comm::RetCode::RET_OK != ret) {
            FinishSession();
            QLErr("session_id %" PRIx64 " SetStringRemote err %d packet_id %d topic \"%s\"",
                  session_id_, phxqueue::comm::as_integer(ret),
                  req.packet_identifier(), req.topic_filters(i).c_str());

            return phxqueue::comm::as_integer(ret);
        }

    }  // foreach req.topic_filters()

    // 4. response
    resp->set_packet_identifier(req.packet_identifier());
    for (int i{0}; req.topic_filters().size() > i; ++i) {
        QLVerb("topic \"%s\"", req.topic_filters(i).c_str());
    }

    QLInfo("session_id %" PRIx64 " packet_id %d", session_id_, req.packet_identifier());

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttPing(const phxqueue_phxrpc::mqttbroker::MqttPingreqPb &req,
                                       phxqueue_phxrpc::mqttbroker::MqttPingrespPb *resp) {
    MqttSession *mqtt_session{nullptr};
    phxqueue::comm::RetCode ret{CheckSession(mqtt_session)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("session_id %" PRIx64 " CheckSession err %d",
              session_id_, phxqueue::comm::as_integer(ret));

        return phxqueue::comm::as_integer(ret);
    }

    mqtt_session->Heartbeat();

    QLInfo("session_id %" PRIx64, session_id_);

    return 0;
}

int MqttBrokerServiceImpl::PhxMqttDisconnect(const phxqueue_phxrpc::mqttbroker::MqttDisconnectPb &req,
                                             google::protobuf::Empty *resp) {
    FinishSession();

    QLInfo("session_id %" PRIx64, session_id_);

    return 0;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::CheckSession(MqttSession *&mqtt_session) {
    const auto tmp_mqtt_session(args_.mqtt_session_mgr->GetBySessionId(session_id_));
    if (!tmp_mqtt_session || tmp_mqtt_session->IsExpired()) {
        QLErr("session_id %" PRIx64 " session %p mqtt_session %p", session_id_, tmp_mqtt_session);
        // ignore return
        FinishSession();

        return phxqueue::comm::RetCode::RET_ERR_LOGIC;
    }
    if (tmp_mqtt_session->IsExpired()) {
        QLErr("session_id %" PRIx64 " mqtt_session expire_time_ms %llu <= now %llu client_id %s",
              session_id_, tmp_mqtt_session->expire_time_ms(),
              phxrpc::Timer::GetSteadyClockMS(), tmp_mqtt_session->client_id.c_str());
        // ignore return
        FinishSession();

        return phxqueue::comm::RetCode::RET_ERR_LOGIC;
    }
    mqtt_session = tmp_mqtt_session;
    QLVerb("session_id %" PRIx64 " client_id %s",
           session_id_, mqtt_session->client_id.c_str());

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::FinishSession() {
    // get client_id
    const auto mqtt_session(args_.mqtt_session_mgr->GetBySessionId(session_id_));
    string client_id(mqtt_session->client_id);

    // destroy local session
    args_.mqtt_session_mgr->DestroyBySessionId(session_id_);
    args_.server_mgr->DestroySession(session_id_);

    // get remote session
    uint64_t version{0uLL};
    phxqueue_phxrpc::mqttbroker::SessionPb session_pb;
    phxqueue::comm::RetCode ret{GetSessionByClientIdRemote(client_id, version, session_pb)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("session_id %" PRIx64 " client_id \"%s\" GetSessionByClientIdRemote err %d",
              session_id_, client_id.c_str(), phxqueue::comm::as_integer(ret));

        return ret;
    }

    // finish remote session
    QLInfo("session_id %" PRIx64 " client_id \"%s\" FinishRemoteSession",
           session_id_, client_id.c_str());
    ret = FinishRemoteSession(client_id, session_pb);
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("session_id %" PRIx64 " client_id \"%s\" FinishRemoteSession err %d",
              session_id_, client_id.c_str(), phxqueue::comm::as_integer(ret));

        return ret;
    }

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode
MqttBrokerServiceImpl::FinishRemoteSession(const string &client_id,
        const phxqueue_phxrpc::mqttbroker::SessionPb &session_pb) {
    const auto &session_attribute(session_pb.session_attribute());
    if (!session_attribute.will_topic().empty() && !session_attribute.will_message().empty()) {
        phxqueue_phxrpc::mqttbroker::HttpPublishPb http_publish_pb;
        http_publish_pb.set_pub_client_id(string("__will__:") + client_id);
        auto &&mqtt_publish_pb(http_publish_pb.mutable_mqtt_publish());
        mqtt_publish_pb->set_qos(session_attribute.will_qos());
        mqtt_publish_pb->set_retain(session_attribute.will_retain());
        mqtt_publish_pb->set_packet_identifier(0);
        mqtt_publish_pb->set_topic_name(session_attribute.will_topic());
        mqtt_publish_pb->set_data(session_attribute.will_message());
        phxqueue::comm::RetCode ret{EnqueueMessage(http_publish_pb)};
        // TODO: ignore ret?
    }

    if (session_attribute.clean_session()) {
        // 1. delete remote session
        phxqueue::comm::RetCode ret{DeleteSessionByClientIdRemote(client_id, -1)};
        if (phxqueue::comm::RetCode::RET_OK != ret) {
            QLErr("session_id %" PRIx64 " DeleteString err %d",
                  session_id_, phxqueue::comm::as_integer(ret));

            return ret;
        }
    } else {
        // 2.1. clear remote session_ip
        auto session_pb2(session_pb);
        session_pb2.set_session_ip(0);

        // 2.2. set remote session
        phxqueue::comm::RetCode ret{SetSessionByClientIdRemote(client_id, -1, session_pb2)};
        if (phxqueue::comm::RetCode::RET_OK != ret) {
            QLErr("session_id %" PRIx64 " client_id \"%s\" SetSessionByClientIdRemote err %d",
                  session_id_, client_id.c_str(),
                  phxqueue::comm::as_integer(ret));

            return ret;
        }
    }

    QLInfo("session_id %" PRIx64 " client_id \"%s\"", session_id_, client_id.c_str());

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode
MqttBrokerServiceImpl::EnqueueMessage(const phxqueue_phxrpc::mqttbroker::HttpPublishPb &message) {
    phxqueue::producer::ProducerOption opt;
    unique_ptr<phxqueue::producer::Producer> producer;
    producer.reset(new phxqueue_phxrpc::producer::Producer(opt));
    producer->Init();

    const uint64_t uin{0};
    const int handle_id{1};
    vector<string> arr;
    phxqueue::comm::utils::StrSplitList(message.mqtt_publish().topic_name(), "/", arr);
    if (2 != arr.size()) {
        QLErr("pub_client_id \"%s\" topic \"%s\" invalid", message.pub_client_id().c_str(),
              message.mqtt_publish().topic_name().c_str());

        return phxqueue::comm::RetCode::RET_ERR_RANGE_TOPIC;
    }
    char *str_end{nullptr};
    errno = 0;
    const long pub_id{strtol(arr.at(1).c_str(), &str_end, 10)};
    if ((arr.at(1).c_str() == str_end) || (0 != errno && 0 == pub_id)) {
        QLErr("pub_client_id \"%s\" pub \"%s\" invalid", message.pub_client_id().c_str(),
              arr.at(1).c_str());

        return phxqueue::comm::RetCode::RET_ERR_RANGE_TOPIC;
    }

    int phxqueue_topic_id{0};
    string phxqueue_topic_name(arr.at(0).c_str());
    phxqueue::comm::RetCode ret{phxqueue::config::GlobalConfig::GetThreadInstance()->
            GetTopicIDByTopicName(phxqueue_topic_name, phxqueue_topic_id)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetTopicIDByTopicName ret %d pub_client_id \"%s\" topic \"%s\"",
              phxqueue::comm::as_integer(ret), message.pub_client_id().c_str(),
              phxqueue_topic_name.c_str());

        return ret;
    }
    string message_string;
    if (!message.SerializeToString(&message_string)) {
        QLErr("SerializeToString err pub_client_id \"%s\"", message.pub_client_id().c_str());

        return phxqueue::comm::RetCode::RET_ERR_PROTOBUF_SERIALIZE;
    }

    ret = producer->Enqueue(phxqueue_topic_id, uin, handle_id,
                            message_string, static_cast<int>(pub_id));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("Enqueue err %d pub_client_id \"%s\" topic %d \"%s\"",
              phxqueue::comm::as_integer(ret), message.pub_client_id().c_str(),
              phxqueue_topic_id, phxqueue_topic_name.c_str());

        return ret;
    }

    QLInfo("pub_client_id \"%s\" topic %d \"%s\"", message.pub_client_id().c_str(),
           phxqueue_topic_id, phxqueue_topic_name.c_str());

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::GetStringRemote(const string &prefix,
        const string &key, uint64_t &version, string &value) {
    int topic_id{-1};
    int lock_id{-1};
    phxqueue::comm::RetCode ret{GetTopicIDAndLockID(topic_id, lock_id)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetTopicIDAndLockID err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    phxqueue::comm::proto::GetStringRequest get_string_req;
    phxqueue::comm::proto::GetStringResponse get_string_resp;

    get_string_req.set_topic_id(topic_id);
    get_string_req.set_lock_id(lock_id);
    get_string_req.set_key(prefix + key);

    phxqueue::lock::LockMasterClient<phxqueue::comm::proto::GetStringRequest,
            phxqueue::comm::proto::GetStringResponse> lock_master_client_get_string;
    ret = lock_master_client_get_string.ClientCall(get_string_req, get_string_resp,
            bind(&MqttBrokerServiceImpl::GetString,
                 this, placeholders::_1, placeholders::_2));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetString err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    version = get_string_resp.string_info().version();
    value = get_string_resp.string_info().value();

    QLInfo("key \"%s%s\"", prefix.c_str(), key.c_str());

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::SetStringRemote(const string &prefix,
        const string &key, const uint64_t version, const string &value) {
    int topic_id{-1};
    int lock_id{-1};
    phxqueue::comm::RetCode ret{GetTopicIDAndLockID(topic_id, lock_id)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetTopicIDAndLockID err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    phxqueue::comm::proto::SetStringRequest set_string_req;
    phxqueue::comm::proto::SetStringResponse set_string_resp;

    set_string_req.set_topic_id(topic_id);
    set_string_req.set_lock_id(lock_id);
    const auto &string_info(set_string_req.mutable_string_info());
    string_info->set_key(prefix + key);
    string_info->set_version(version);
    string_info->set_value(value);
    string_info->set_lease_time_ms(-1);

    phxqueue::lock::LockMasterClient<phxqueue::comm::proto::SetStringRequest,
            phxqueue::comm::proto::SetStringResponse> lock_master_client_set_string;
    ret = lock_master_client_set_string.ClientCall(set_string_req, set_string_resp,
            bind(&MqttBrokerServiceImpl::SetString,
                 this, placeholders::_1, placeholders::_2));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("SetString err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    QLInfo("key \"%s%s\"", prefix.c_str(), key.c_str());

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::DeleteStringRemote(const string &prefix,
        const string &key, const uint64_t version) {
    int topic_id{-1};
    int lock_id{-1};
    phxqueue::comm::RetCode ret{GetTopicIDAndLockID(topic_id, lock_id)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetTopicIDAndLockID err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    phxqueue::comm::proto::DeleteStringRequest delete_string_req;
    phxqueue::comm::proto::DeleteStringResponse delete_string_resp;

    delete_string_req.set_topic_id(topic_id);
    delete_string_req.set_lock_id(lock_id);
    const auto &string_key_info(delete_string_req.mutable_string_key_info());
    string_key_info->set_key(prefix + key);
    string_key_info->set_version(version);

    phxqueue::lock::LockMasterClient<phxqueue::comm::proto::DeleteStringRequest,
            phxqueue::comm::proto::DeleteStringResponse> lock_master_client_set_string;
    ret = lock_master_client_set_string.ClientCall(delete_string_req, delete_string_resp,
            bind(&MqttBrokerServiceImpl::DeleteString,
                 this, placeholders::_1, placeholders::_2));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("DeleteString err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    QLInfo("key \"%s%s\"", prefix.c_str(), key.c_str());

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::LockRemote(const string &lock_key,
        const string &client_id, const uint64_t lease_time) {
    // 1. get topic_id and lock_id
    int topic_id{-1};
    int lock_id{-1};
    string full_lock_key(KEY_BROKER_TOPIC2LOCK);
    full_lock_key += lock_key;
    phxqueue::comm::RetCode ret{GetTopicIDAndLockID(topic_id, lock_id)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetTopicIDAndLockID err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    // 2. get lock info
    phxqueue::comm::proto::GetLockInfoRequest get_lock_info_req;
    phxqueue::comm::proto::GetLockInfoResponse get_lock_info_resp;

    get_lock_info_req.set_topic_id(topic_id);
    get_lock_info_req.set_lock_id(lock_id);
    get_lock_info_req.set_lock_key(full_lock_key);

    phxqueue::lock::LockMasterClient<phxqueue::comm::proto::GetLockInfoRequest,
            phxqueue::comm::proto::GetLockInfoResponse> lock_master_client_get_lock_info;
    ret = lock_master_client_get_lock_info.ClientCall(get_lock_info_req, get_lock_info_resp,
            bind(&MqttBrokerServiceImpl::GetLockInfo, this, placeholders::_1, placeholders::_2));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetLockInfo err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    // 3. acquire lock
    phxqueue::comm::proto::AcquireLockRequest acquire_lock_req;
    phxqueue::comm::proto::AcquireLockResponse acquire_lock_resp;

    acquire_lock_req.set_topic_id(topic_id);
    acquire_lock_req.set_lock_id(lock_id);
    auto &&lock_info = acquire_lock_req.mutable_lock_info();
    lock_info->set_lock_key(full_lock_key);
    lock_info->set_version(get_lock_info_resp.lock_info().version());
    lock_info->set_client_id(client_id);
    lock_info->set_lease_time_ms(lease_time);

    phxqueue::lock::LockMasterClient<phxqueue::comm::proto::AcquireLockRequest,
            phxqueue::comm::proto::AcquireLockResponse> lock_master_client_acquire_lock;
    ret = lock_master_client_acquire_lock.ClientCall(acquire_lock_req, acquire_lock_resp,
            bind(&MqttBrokerServiceImpl::AcquireLock, this, placeholders::_1, placeholders::_2));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("AcquireLock err %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    QLInfo("key \"%s%s\"", full_lock_key.c_str());

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::GetSessionByClientIdRemote(const string &client_id,
        uint64_t &version, phxqueue_phxrpc::mqttbroker::SessionPb &session_pb) {
    // 1. get client_id -> session from lock
    string session_pb_string;
    phxqueue::comm::RetCode ret{GetStringRemote(string(KEY_BROKER_CLIENT2SESSION_PREFIX),
                                                client_id, version, session_pb_string)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("client_id \"%s\" GetStringRemote err %d",
              client_id.c_str(), phxqueue::comm::as_integer(ret));

        return ret;
    }

    // 2. parse
    if (!session_pb.ParseFromString(session_pb_string)) {
        QLErr("client_id \"%s\" ParseFromString err", client_id.c_str());

        return phxqueue::comm::RetCode::RET_ERR_PROTOBUF_PARSE;
    }

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::SetSessionByClientIdRemote(const string &client_id,
        const uint64_t version, phxqueue_phxrpc::mqttbroker::SessionPb const &session_pb) {
    // 1. serialize
    string session_pb_string;
    if (!session_pb.SerializeToString(&session_pb_string)) {
        QLErr("client_id \"%s\" SerializeToString err", client_id.c_str());

        return phxqueue::comm::RetCode::RET_ERR_PROTOBUF_SERIALIZE;
    }

    // 2. set client_id -> session to lock
    phxqueue::comm::RetCode ret{SetStringRemote(string(KEY_BROKER_CLIENT2SESSION_PREFIX),
                                                client_id, version, session_pb_string)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("client_id \"%s\" SetStringRemote err %d",
              client_id.c_str(), phxqueue::comm::as_integer(ret));

        return ret;
    }

    session_pb_string.clear();
    uint64_t version2;
    ret = GetStringRemote(string(KEY_BROKER_CLIENT2SESSION_PREFIX),
                          client_id, version2, session_pb_string);
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("client_id \"%s\" GetStringRemote err %d",
              client_id.c_str(), phxqueue::comm::as_integer(ret));

        return ret;
    }

    // TODO: remove
    phxqueue_phxrpc::mqttbroker::SessionPb session_pb2;
    if (!session_pb2.ParseFromString(session_pb_string)) {
        QLErr("client_id \"%s\" ParseFromString err", client_id.c_str());

        return phxqueue::comm::RetCode::RET_ERR_PROTOBUF_PARSE;
    }
    QLInfo("client_id \"%s\" ok ip %u session %" PRIx64, client_id.c_str(),
           session_pb2.session_ip(), session_pb2.session_id());

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::DeleteSessionByClientIdRemote(const string &client_id,
                                                                             const uint64_t version) {
    phxqueue::comm::RetCode ret{DeleteStringRemote(string(KEY_BROKER_CLIENT2SESSION_PREFIX),
                                                   client_id, version)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("client_id \"%s\" DeleteStringRemote err %d",
              client_id.c_str(), phxqueue::comm::as_integer(ret));

        return ret;
    }

    return phxqueue::comm::RetCode::RET_OK;
}

phxqueue::comm::RetCode
MqttBrokerServiceImpl::GetLockInfo(const phxqueue::comm::proto::GetLockInfoRequest &req,
                                   phxqueue::comm::proto::GetLockInfoResponse &resp) {
    thread_local LockClient lock_client;
    auto ret = lock_client.ProtoGetLockInfo(req, resp);
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("ProtoGetLockInfo ret %d", phxqueue::comm::as_integer(ret));

        return ret;
    }
    QLInfo("ProtoGetLockInfo ok");

    return ret;
}

phxqueue::comm::RetCode
MqttBrokerServiceImpl::AcquireLock(const phxqueue::comm::proto::AcquireLockRequest &req,
                                   phxqueue::comm::proto::AcquireLockResponse &resp) {
    thread_local LockClient lock_client;
    auto ret = lock_client.ProtoAcquireLock(req, resp);
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("ProtoAcquireLock ret %d", phxqueue::comm::as_integer(ret));

        return ret;
    }
    QLInfo("ProtoAcquireLock ok");

    return ret;
}

phxqueue::comm::RetCode
MqttBrokerServiceImpl::GetString(const phxqueue::comm::proto::GetStringRequest &req,
                                 phxqueue::comm::proto::GetStringResponse &resp) {
    thread_local LockClient lock_client;
    const auto ret(lock_client.ProtoGetString(req, resp));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("ProtoGetString ret %d", phxqueue::comm::as_integer(ret));

        return ret;
    }
    QLInfo("ProtoGetString ok");

    return ret;
}

phxqueue::comm::RetCode
MqttBrokerServiceImpl::SetString(const phxqueue::comm::proto::SetStringRequest &req,
                                 phxqueue::comm::proto::SetStringResponse &resp) {
    thread_local LockClient lock_client;
    const auto ret(lock_client.ProtoSetString(req, resp));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("ProtoSetString ret %d", phxqueue::comm::as_integer(ret));

        return ret;
    }
    QLInfo("ProtoSetString ok");

    return ret;
}

phxqueue::comm::RetCode
MqttBrokerServiceImpl::DeleteString(const phxqueue::comm::proto::DeleteStringRequest &req,
                                    phxqueue::comm::proto::DeleteStringResponse &resp) {
    thread_local LockClient lock_client;
    const auto ret(lock_client.ProtoDeleteString(req, resp));
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("ProtoDeleteString ret %d", phxqueue::comm::as_integer(ret));

        return ret;
    }
    QLInfo("ProtoDeleteString ok");

    return ret;
}

phxqueue::comm::RetCode MqttBrokerServiceImpl::GetTopicIDAndLockID(int &topic_id, int &lock_id) {
    topic_id = args_.config->GetTopicID();

    shared_ptr<const phxqueue::config::LockConfig> lock_config;
    phxqueue::comm::RetCode ret{phxqueue::config::GlobalConfig::GetThreadInstance()->GetLockConfig(topic_id, lock_config)};
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetLockConfig ret %d topic_id %u", phxqueue::comm::as_integer(ret), topic_id);

        return ret;
    }

    set<int> lock_ids;
    ret = lock_config->GetAllLockID(lock_ids);
    if (phxqueue::comm::RetCode::RET_OK != ret) {
        QLErr("GetAllLockID ret %d", phxqueue::comm::as_integer(ret));

        return ret;
    }

    if (lock_ids.empty()) {
        QLErr("lock_ids empty");

        return phxqueue::comm::RetCode::RET_ERR_RANGE_LOCK;
    }

    lock_id = *lock_ids.begin();

    return phxqueue::comm::RetCode::RET_OK;
}

