/* mqttbroker_client.cpp

 Generated by phxrpc_pb2client from mqttbroker.proto

*/



#include "mqttbroker_client_uthread.h"

#include <cstdlib>
#include <memory>
#include <mutex>

#include "phxrpc/http.h"
#include "phxrpc/rpc.h"

#include "mqtt/mqtt_msg_handler_factory.h"
#include "phxrpc_mqttbroker_stub.h"
#include "resource_pool.h"


using namespace phxqueue_phxrpc::logic::mqtt;
using namespace std;


static phxrpc::ClientConfig global_mqttbrokerclientuthread_config_;
static phxrpc::ClientMonitorPtr global_mqttbrokerclientuthread_monitor_;


bool MqttBrokerClientUThread::Init(const char *config_file) {
    return global_mqttbrokerclientuthread_config_.Read(config_file);
}

const char *MqttBrokerClientUThread::GetPackageName() {
    const char *ret{global_mqttbrokerclientuthread_config_.GetPackageName()};
    if (strlen(ret) == 0) {
        ret = "mqttbroker";
    }
    return ret;
}

MqttBrokerClientUThread::MqttBrokerClientUThread(phxrpc::UThreadEpollScheduler *uthread_scheduler) {
    uthread_scheduler_ = uthread_scheduler;
    static mutex monitor_mutex;
    if (!global_mqttbrokerclientuthread_monitor_.get()) {
        monitor_mutex.lock();
        if (!global_mqttbrokerclientuthread_monitor_.get()) {
            global_mqttbrokerclientuthread_monitor_ = phxrpc::MonitorFactory::GetFactory()->
                    CreateClientMonitor(GetPackageName());
        }
        global_mqttbrokerclientuthread_config_.SetClientMonitor(global_mqttbrokerclientuthread_monitor_);
        monitor_mutex.unlock();
    }
}

MqttBrokerClientUThread::~MqttBrokerClientUThread() {
}

// http protocol

int MqttBrokerClientUThread::PHXEcho(const google::protobuf::StringValue &req,
                                     google::protobuf::StringValue *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxrpc::HttpMessageHandlerFactory http_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), http_msg_factory);
        int ret{stub.PHXEcho(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::HttpPublish(const HttpPublishPb &req, HttpPubackPb *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxrpc::HttpMessageHandlerFactory http_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), http_msg_factory);
        int ret{stub.HttpPublish(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

// mqtt protocol

int MqttBrokerClientUThread::MqttConnect(const MqttConnectPb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttConnect(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttConnectWithConnack(const MqttConnectPb &req, MqttConnackPb *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttConnectWithConnack(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttPublish(const MqttPublishPb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttPublish(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttPublishWithPuback(const MqttPublishPb &req, MqttPubackPb *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttPublishWithPuback(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttPuback(const MqttPubackPb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttPuback(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttPubrec(const MqttPubrecPb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttPubrec(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttPubrel(const MqttPubrelPb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttPubrel(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttPubcomp(const MqttPubcompPb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttPubcomp(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttSubscribe(const MqttSubscribePb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttSubscribe(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttSubscribeWithSuback(const MqttSubscribePb &req, MqttSubackPb *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttSubscribeWithSuback(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttUnsubscribe(const MqttUnsubscribePb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttUnsubscribe(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttUnsubscribeWithUnsuback(const MqttUnsubscribePb &req, MqttUnsubackPb *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttUnsubscribeWithUnsuback(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttPing(const MqttPingreqPb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttPing(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttPingWithPingresp(const MqttPingreqPb &req, MqttPingrespPb *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttPingWithPingresp(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

int MqttBrokerClientUThread::MqttDisconnect(const MqttDisconnectPb &req, google::protobuf::Empty *resp) {
    const phxrpc::Endpoint_t *ep{global_mqttbrokerclientuthread_config_.GetRandom()};

    if (uthread_scheduler_ && ep) {
        auto &&socket_pool(ResourcePool<uint64_t, phxrpc::UThreadTcpStream>::GetInstance());
        // TODO:
        uint64_t key(ep->port);
        auto socket = move(socket_pool->Get(key));

        if (nullptr == socket.get()) {
            socket.reset(new phxrpc::UThreadTcpStream());

            bool open_ret{phxrpc::PhxrpcTcpUtils::Open(uthread_scheduler_, socket.get(), ep->ip, ep->port,
                    global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(),
                    *(global_mqttbrokerclientuthread_monitor_.get()))};
            if (!open_ret) {
                phxrpc::log(LOG_ERR, "Open %s:%d err %d", ep->ip, ep->port, open_ret);

                return -1;
            }
            socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
        }

        phxqueue_phxrpc::mqttbroker::MqttMessageHandlerFactory mqtt_msg_factory;
        MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), mqtt_msg_factory);
        int ret{stub.MqttDisconnect(req, resp)};
        socket_pool->Put(key, socket);

        return ret;
    }

    return -1;
}

// proto

phxqueue::comm::RetCode
MqttBrokerClientUThread::ProtoHttpPublish(const phxqueue_phxrpc::logic::mqtt::HttpPublishPb &req,
                                          phxqueue_phxrpc::logic::mqtt::HttpPubackPb *resp) {
    const char *ip{req.addr().ip().c_str()};
    const int port{req.addr().port()};

    auto &&socket_pool(phxqueue::comm::ResourcePool<uint64_t, phxrpc::BlockTcpStream>::GetInstance());
    auto &&key(phxqueue::comm::utils::EncodeAddr(req.addr()));
    auto socket(move(socket_pool->Get(key)));

    if (nullptr == socket.get()) {
        socket.reset(new phxrpc::BlockTcpStream());

        bool open_ret{phxrpc::PhxrpcTcpUtils::Open(socket.get(), ip, port,
                                                   global_mqttbrokerclientuthread_config_.GetConnectTimeoutMS(), nullptr, 0,
                                                   *(global_mqttbrokerclientuthread_monitor_.get()))};
        if (!open_ret) {
            QLErr("phxrpc Open err. ip %s port %d", ip, port);

            return phxqueue::comm::RetCode::RET_ERR_SYS;
        }
        socket->SetTimeout(global_mqttbrokerclientuthread_config_.GetSocketTimeoutMS());
    }

    phxrpc::HttpMessageHandlerFactory http_msg_factory;
    MqttBrokerStub stub(*(socket.get()), *(global_mqttbrokerclientuthread_monitor_.get()), http_msg_factory);
    stub.set_keep_alive(true);
    int ret{stub.HttpPublish(req, resp)};
    if (0 > ret) {
        QLErr("HttpPublish err %d", ret);
    }
    if (-1 != ret && -202 != ret) {
        socket_pool->Put(key, socket);
    }
    return static_cast<phxqueue::comm::RetCode>(ret);
}

