/* mqttbroker_tool_impl.cpp

 Generated by phxrpc_pb2tool from mqttbroker.proto

*/

#include "mqttbroker_tool_impl.h"

#include <algorithm>

#include "phxqueue/comm.h"
#include "phxrpc/file.h"

#include "mqttbroker.pb.h"
#include "mqttbroker_client.h"


using namespace phxqueue_phxrpc::logic::mqtt;
using namespace phxrpc;
using namespace std;


MqttBrokerToolImpl::MqttBrokerToolImpl() {
}

MqttBrokerToolImpl::~MqttBrokerToolImpl() {
}

int MqttBrokerToolImpl::PHXEcho(phxrpc::OptMap &opt_map) {
    google::protobuf::StringValue req;
    google::protobuf::StringValue resp;

    if (nullptr == opt_map.Get('s')) return -1;

    req.set_value(opt_map.Get('s'));

    MqttBrokerClient client;
    int ret{client.PHXEcho(req, &resp)};
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return ret;
}

int MqttBrokerToolImpl::HttpPublish(phxrpc::OptMap &opt_map) {
    HttpPublishPb req;
    HttpPubackPb resp;

    const char *pub_client_id{opt_map.Get('x')};
    const char *sub_client_id{opt_map.Get('y')};

    uint32_t dup{0u};
    if (!opt_map.GetUInt('d', &dup)) dup = 0;
    uint32_t qos{0u};
    if (!opt_map.GetUInt('q', &qos)) qos = 0;
    uint32_t retain{0u};
    if (!opt_map.GetUInt('r', &retain)) retain = 0;

    if (nullptr == opt_map.Get('t')) return -1;
    uint32_t packet_identifier{0u};
    if (!opt_map.GetUInt('p', &packet_identifier)) packet_identifier = 0;
    if (nullptr == opt_map.Get('s')) return -1;

    req.set_pub_client_id(pub_client_id);
    req.set_sub_client_id(sub_client_id);

    req.mutable_mqtt_publish()->set_dup(0 != dup);
    req.mutable_mqtt_publish()->set_qos(qos);
    req.mutable_mqtt_publish()->set_retain(0 != retain);

    req.mutable_mqtt_publish()->set_topic_name(opt_map.Get('t'));
    req.mutable_mqtt_publish()->set_packet_identifier(packet_identifier);
    req.mutable_mqtt_publish()->set_data(opt_map.Get('s'));

    MqttBrokerClient client;
    int ret{client.HttpPublish(req, &resp)};
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return ret;
}

int MqttBrokerToolImpl::MqttConnect(phxrpc::OptMap &opt_map) {
    MqttBrokerClient client;
    int ret{-1};

    MqttConnectPb req;
    MqttConnackPb resp;

    if (nullptr == opt_map.Get('l')) return -1;

    req.set_client_identifier(opt_map.Get('l'));
    req.set_proto_name("MQTT");
    req.set_proto_level(4);
    req.set_keep_alive(0);

    ret = client.MqttConnectWithConnack(req, &resp);
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return ret;
}

int MqttBrokerToolImpl::MqttPublish(phxrpc::OptMap &opt_map) {
    MqttBrokerClient client;
    int ret{-1};

    MqttConnectPb connect_req;
    MqttConnackPb connect_resp;

    if (nullptr == opt_map.Get('l')) return -1;

    connect_req.set_client_identifier(opt_map.Get('l'));
    connect_req.set_proto_name("MQTT");
    connect_req.set_proto_level(4);
    connect_req.set_keep_alive(0);

    ret = client.MqttConnectWithConnack(connect_req, &connect_resp);
    printf("%s connect return %d\n", __func__, ret);
    printf("connect resp: {\n%s}\n", connect_resp.DebugString().c_str());

    MqttPublishPb req;

    uint32_t dup{0u};
    if (!opt_map.GetUInt('d', &dup)) dup = 0;
    uint32_t qos{0u};
    if (!opt_map.GetUInt('q', &qos)) qos = 0;
    uint32_t retain{0u};
    if (!opt_map.GetUInt('r', &retain)) retain = 0;

    if (nullptr == opt_map.Get('t')) return -1;
    uint32_t packet_identifier{0u};
    if (!opt_map.GetUInt('p', &packet_identifier)) packet_identifier = 0;
    if (nullptr == opt_map.Get('s')) return -1;

    req.set_dup(0 != dup);
    req.set_qos(qos);
    req.set_retain(0 != retain);

    req.set_topic_name(opt_map.Get('t'));
    req.set_packet_identifier(packet_identifier);
    req.set_data(opt_map.Get('s'));

    if (1 == qos) {
        MqttPubackPb resp;
        ret = client.MqttPublishWithPuback(req, &resp);
        printf("%s return %d\n", __func__, ret);
        printf("resp: {\n%s}\n", resp.DebugString().c_str());
    } else {
        google::protobuf::Empty resp;
        ret = client.MqttPublish(req, &resp);
        printf("%s return %d\n", __func__, ret);
        printf("resp: {\n%s}\n", resp.DebugString().c_str());
    }

    return ret;
}

int MqttBrokerToolImpl::MqttPuback(phxrpc::OptMap &opt_map) {
    MqttBrokerClient client;
    int ret{-1};

    MqttConnectPb connect_req;
    MqttConnackPb connect_resp;

    if (nullptr == opt_map.Get('l')) return -1;

    connect_req.set_client_identifier(opt_map.Get('l'));
    connect_req.set_proto_name("MQTT");
    connect_req.set_proto_level(4);
    connect_req.set_keep_alive(0);

    ret = client.MqttConnectWithConnack(connect_req, &connect_resp);
    printf("%s connect return %d\n", __func__, ret);
    printf("connect resp: {\n%s}\n", connect_resp.DebugString().c_str());

    MqttPubackPb req;
    google::protobuf::Empty resp;

    uint32_t packet_identifier{0u};
    if (!opt_map.GetUInt('p', &packet_identifier)) packet_identifier = 0;

    req.set_packet_identifier(packet_identifier);

    ret = client.MqttPuback(req, &resp);
    printf("%s return %d\n", __func__, ret);

    return ret;
}

int MqttBrokerToolImpl::MqttPubrec(phxrpc::OptMap &opt_map) {
    MqttPubrecPb req;
    google::protobuf::Empty resp;

    // TODO: fill req from opt_map

    MqttBrokerClient client;
    int ret{client.MqttPubrec(req, &resp)};
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return ret;
}

int MqttBrokerToolImpl::MqttPubrel(phxrpc::OptMap &opt_map) {
    MqttPubrelPb req;
    google::protobuf::Empty resp;

    // TODO: fill req from opt_map

    MqttBrokerClient client;
    int ret{client.MqttPubrel(req, &resp)};
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return ret;
}

int MqttBrokerToolImpl::MqttPubcomp(phxrpc::OptMap &opt_map) {
    MqttPubcompPb req;
    google::protobuf::Empty resp;

    // TODO: fill req from opt_map

    MqttBrokerClient client;
    int ret{client.MqttPubcomp(req, &resp)};
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return ret;
}

int MqttBrokerToolImpl::MqttSubscribe(phxrpc::OptMap &opt_map) {
    MqttBrokerClient client;
    int ret{-1};

    MqttConnectPb connect_req;
    MqttConnackPb connect_resp;

    if (nullptr == opt_map.Get('l')) return -1;

    connect_req.set_client_identifier(opt_map.Get('l'));
    connect_req.set_proto_name("MQTT");
    connect_req.set_proto_level(4);
    connect_req.set_keep_alive(0);

    ret = client.MqttConnectWithConnack(connect_req, &connect_resp);
    printf("%s connect return %d\n", __func__, ret);
    printf("connect resp: {\n%s}\n", connect_resp.DebugString().c_str());

    MqttSubscribePb req;
    MqttSubackPb resp;

    uint32_t packet_identifier{0u};
    if (!opt_map.GetUInt('p', &packet_identifier)) packet_identifier = 0;
    if (nullptr == opt_map.Get('t')) return -1;
    if (nullptr == opt_map.Get('q')) return -1;

    req.set_packet_identifier(packet_identifier);

    vector<string> topic_filters;
    FileUtils::StrSplitList(opt_map.Get('t'), ",", topic_filters);
    google::protobuf::RepeatedPtrField<string> temp_topic_filters(
            topic_filters.begin(), topic_filters.end());
    req.mutable_topic_filters()->Swap(&temp_topic_filters);
    printf("topics ");
    for_each(req.topic_filters().begin(), req.topic_filters().end(),
            [](const string &s) {
                printf("%s,", s.c_str());
            });
    printf("\n");

    vector<string> qoss;
    FileUtils::StrSplitList(opt_map.Get('q'), ",", qoss);
    vector<uint32_t> qoss2;
    for_each(qoss.begin(), qoss.end(),
             [&qoss2](const string &s) { qoss2.push_back(strtoul(s.c_str(), nullptr, 10)); });
    google::protobuf::RepeatedField<uint32_t> temp_qoss(
            qoss2.begin(), qoss2.end());
    req.mutable_qoss()->Swap(&temp_qoss);
    printf("qos ");
    for_each(req.qoss().begin(), req.qoss().end(),
            [](const uint32_t &u) {
                printf("%u,", u);
            });
    printf("\n");

    ret = client.MqttSubscribeWithSuback(req, &resp);
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return 0;
}

int MqttBrokerToolImpl::MqttUnsubscribe(phxrpc::OptMap &opt_map) {
    MqttBrokerClient client;
    int ret{-1};

    MqttConnectPb connect_req;
    MqttConnackPb connect_resp;

    if (nullptr == opt_map.Get('l')) return -1;

    connect_req.set_client_identifier(opt_map.Get('l'));
    connect_req.set_proto_name("MQTT");
    connect_req.set_proto_level(4);
    connect_req.set_keep_alive(0);

    ret = client.MqttConnectWithConnack(connect_req, &connect_resp);
    printf("%s connect return %d\n", __func__, ret);
    printf("connect resp: {\n%s}\n", connect_resp.DebugString().c_str());

    MqttUnsubscribePb req;
    MqttUnsubackPb resp;

    uint32_t packet_identifier{0u};
    if (!opt_map.GetUInt('p', &packet_identifier)) packet_identifier = 0;
    if (nullptr == opt_map.Get('t')) return -1;

    req.set_packet_identifier(packet_identifier);

    vector<string> topic_filters;
    FileUtils::StrSplitList(opt_map.Get('t'), ",", topic_filters);
    google::protobuf::RepeatedPtrField<string> temp_topic_filters(
            topic_filters.begin(), topic_filters.end());
    req.mutable_topic_filters()->Swap(&temp_topic_filters);

    ret = client.MqttUnsubscribeWithUnsuback(req, &resp);
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return 0;
}

int MqttBrokerToolImpl::MqttPing(phxrpc::OptMap &opt_map) {
    MqttBrokerClient client;
    int ret{-1};

    MqttConnectPb connect_req;
    MqttConnackPb connect_resp;

    if (nullptr == opt_map.Get('l')) return -1;

    connect_req.set_client_identifier(opt_map.Get('l'));
    connect_req.set_proto_name("MQTT");
    connect_req.set_proto_level(4);
    connect_req.set_keep_alive(0);

    ret = client.MqttConnectWithConnack(connect_req, &connect_resp);
    printf("%s connect return %d\n", __func__, ret);
    printf("connect resp: {\n%s}\n", connect_resp.DebugString().c_str());

    MqttPingreqPb req;
    MqttPingrespPb resp;

    ret = client.MqttPingWithPingresp(req, &resp);
    printf("%s return %d\n", __func__, ret);
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return 0;
}

int MqttBrokerToolImpl::MqttDisconnect(phxrpc::OptMap &opt_map) {
    MqttBrokerClient client;
    int ret{-1};

    MqttConnectPb connect_req;
    MqttConnackPb connect_resp;

    if (nullptr == opt_map.Get('l')) return -1;

    connect_req.set_client_identifier(opt_map.Get('l'));
    connect_req.set_proto_name("MQTT");
    connect_req.set_proto_level(4);
    connect_req.set_keep_alive(0);

    ret = client.MqttConnectWithConnack(connect_req, &connect_resp);
    printf("%s connect return %d\n", __func__, ret);
    printf("connect resp: {\n%s}\n", connect_resp.DebugString().c_str());

    MqttDisconnectPb req;
    google::protobuf::Empty resp;

    ret = client.MqttDisconnect(req, &resp);
    printf("%s return %d\n", __func__, ret);

    return ret;
}

int MqttBrokerToolImpl::ProtoHttpPublish(phxrpc::OptMap &opt_map) {
    HttpPublishPb req;
    HttpPubackPb resp;

    const char *ip{opt_map.Get('i')};
    int port{9100};
    if (!opt_map.GetInt('o', &port)) port = 9100;

    const char *pub_client_id{opt_map.Get('x')};
    const char *sub_client_id{opt_map.Get('y')};

    uint32_t dup{0u};
    if (!opt_map.GetUInt('d', &dup)) dup = 0;
    uint32_t qos{0u};
    if (!opt_map.GetUInt('q', &qos)) qos = 0;
    uint32_t retain{0u};
    if (!opt_map.GetUInt('r', &retain)) retain = 0;

    if (nullptr == opt_map.Get('t')) return -1;
    uint32_t packet_identifier{0u};
    if (!opt_map.GetUInt('p', &packet_identifier)) packet_identifier = 0;
    if (nullptr == opt_map.Get('s')) return -1;

    if (0 < strlen(ip)) {
        req.mutable_addr()->set_ip(ip);
    } else {
        req.mutable_addr()->set_ip("127.0.0.1");
    }
    req.mutable_addr()->set_port(port);
    req.set_pub_client_id(pub_client_id);
    req.set_sub_client_id(sub_client_id);

    req.mutable_mqtt_publish()->set_dup(0 != dup);
    req.mutable_mqtt_publish()->set_qos(qos);
    req.mutable_mqtt_publish()->set_retain(0 != retain);

    req.mutable_mqtt_publish()->set_topic_name(opt_map.Get('t'));
    req.mutable_mqtt_publish()->set_packet_identifier(packet_identifier);
    req.mutable_mqtt_publish()->set_data(opt_map.Get('s'));

    MqttBrokerClient client;
    phxqueue::comm::RetCode ret{client.ProtoHttpPublish(req, &resp)};
    printf("%s return %d\n", __func__, phxqueue::comm::as_integer(ret));
    printf("resp: {\n%s}\n", resp.DebugString().c_str());

    return phxqueue::comm::as_integer(ret);
}

